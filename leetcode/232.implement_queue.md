232. Implement Queue using Stacks

简单

https://leetcode-cn.com/problems/implement-queue-using-stacks/

Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).

Implement the MyQueue class:
```
void push(int x) Pushes element x to the back of the queue.
int pop() Removes the element from the front of the queue and returns it.
int peek() Returns the element at the front of the queue.
boolean empty() Returns true if the queue is empty, false otherwise.
```

Notes:

You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.
Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.
 
```
Example 1:

Input
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
Output
[null, null, null, 1, 1, false]

Explanation
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
``` 

Constraints:
```
1 <= x <= 9
At most 100 calls will be made to push, pop, peek, and empty.
All the calls to pop and peek are valid.
``` 

Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer.


相关企业

- 亚马逊 Amazon|8
- 微软 Microsoft|5
- 高盛集团 Goldman Sachs|3
- 字节跳动|2
- 谷歌 Google|2

相关标签
- Stack
- Design
- Queue

相似题目
- Implement Stack using Queues
简单

#  Use Array (may  fake array overflow)

- head: index for first ele
- tail: index of last ele + 1
- first ele push: no special
- empty: head == tail
- one element: head + 1 == tail
- full: tail >= maxsize

```java
class MyQueue {
    private int head;
    private int tail;
    private int MAXSIZE = 100;
    private int[] elements;

    public MyQueue() {
        this.head = 0;
        this.tail = 0;
        this.elements = new int[this.MAXSIZE];
    }
    
    public void push(int x) {
        if (this.tail >= this.MAXSIZE){
            return; // it is full. Push failed.
        }
        this.elements[this.tail] = x;
        this.tail ++;
    }
    
    public int pop() {
        if (this.head == this.tail){
            return -1; // empty
        }
        int firstEleValue = this.elements[this.head];
        this.head ++;
        return firstEleValue;
    }
    
    public int peek() {
        return this.elements[this.head];
    }
    
    public boolean empty() {
        if (this.head == this.tail){
            return true;
        }
        return false;
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```


# Implement Circular Queue Use Array (solve  fake array overflow)

- head: index for first ele
- tail: index of last ele + 1
- first ele push: no special
- empty: head == tail
- one element: head + 1 == tail
- full: (tail + 1) % MAXSIZE == head. Always leave one element/spot empty to help us  to determine when is full.

```java
class MyQueue {
    private int head;
    private int tail;
    private int MAXSIZE = 100;
    private int[] elements;
    // always leave one ele/spot empty to help us to determine when full.

    public MyQueue() {
        this.head = 0;
        this.tail = 0;
        this.elements = new int[this.MAXSIZE];
    }
    
    public void push(int x) {
        if ((this.tail + 1) % this.MAXSIZE == head){
            return; // it is full. Push failed.
        }
        this.elements[this.tail] = x;
        this.tail = (this.tail + 1) % this.MAXSIZE;
    }
    
    public int pop() {
        if (this.head == this.tail){
            return -1; // empty
        }
        int firstEleValue = this.elements[this.head];
        this.head ++;
        return firstEleValue;
    }
    
    public int peek() {
        return this.elements[this.head];
    }
    
    public boolean empty() {
        if (this.head == this.tail){
            return true;
        }
        return false;
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```

#  Use LinkedList
- head: pointer to fisrt ele;
- tail: pointer to last ele;
- fisrt ele push: head == null
- empty: head == null;
- one element: head == tail;
  
```java
class Node {
    public int value;
    public Node next;

    public Node(int v){
        this.value = v;
        this.next = null;
    }
}
class MyQueue {
    private Node head;
    private Node tail;
       
    public MyQueue() {
        this.head = this.tail = null;
    }
    
    public void push(int x) {
        if (this.head == null){
            // fisrt ele push
            this.head = new Node(x);
            this.tail = this.head; // head tial point to same node bc there is only one
            return;
        }
        Node newtail = new Node(x);
        this.tail.next = newtail;
        this.tail = newtail;
    }
    
    public int pop() {
        if (this.head == null){
            System.out.println("empty so pop failed.");
            return -1; // empty
        }
        int firstEleValue = this.head.value;
        this.head = this.head.next;
        return firstEleValue;
    }
    
    public int peek() {
        if (this.head == null){
            System.out.println("empty so peek failed.");
            return -1; // empty
        }
        return this.head.value;
    }
    
    public boolean empty() {
        if (this.head == null){
            return true;
        }
        return false;
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```  

# Use Interfaace Queue (Class LinkedList)
```java
class MyQueue {
    private Queue<Integer> elements;
       
    public MyQueue() {
        this.elements = new LinkedList<Integer>();
    }
    
    public void push(int x) {
        this.elements.add(x);
    }
    
    public int pop() {
        return this.elements.poll();
    }
    
    public int peek() {
        return this.elements.peek();
    }
    
    public boolean empty() {
        if (this.elements.peek() == null){
            return true;
        }
        return false;
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```

# Use Interface Deque (Class ArrayDeque)

```java
class MyQueue {
    private Deque<Integer> elements;
       
    public MyQueue() {
        this.elements = new ArrayDeque<Integer>();
    }
    
    public void push(int x) {
        this.elements.addLast(x);
    }
    
    public int pop() {
        return this.elements.pollFirst();
    }
    
    public int peek() {
        return this.elements.getFirst();
    }
    
    public boolean empty() {
        return this.elements.isEmpty();
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```


# Use Abstract Class AbstractQueue


Since AbstractQueue is an abstract class, it’s implementation is provided by its sub-classes. Below shows the list of classes that can provide the implementation. To create it, we need to it from java.util.AbstractQueue.

- protected AbstractQueue(): The default constructor, but being abstract, it doesn’t allow to create an AbstractQueue object. 
- The implementation should be provided by one of its subclasses like 
- - ArrayBlockingQueue, 
  - ConcurrentLinkedQueue, 
  - DelayQueue, 
  - LinkedBlockingDeque, 
  - LinkedBlockingQueue, 
  - LinkedTransferQueue, 
  - PriorityBlockingQueue, 
  - PriorityQueue, 
  - SynchronousQueue.

AbstractQueue<E> objName = new ArrayBlockingQueue<E>();
```java
import java.util.AbstractQueue;
class MyQueue {
    private AbstractQueue<Integer> elements;
       
    public MyQueue() {
        this.elements = new LinkedBlockingQueue<Integer>();
    }
    
    public void push(int x) {
        this.elements.offer(x);
    }
    
    public int pop() {
        return this.elements.poll(); // remove head ele
    }
    
    public int peek() {
        return this.elements.peek();
    }
    
    public boolean empty() {
        if (this.elements== null || this.elements.size() == 0){
            return true;
        }
        return false;
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```

# Use Class Stack

```java
class MyQueue {
    // only use one to store all elements. The other one must be empty.
    private Stack<Integer> stackHeadAtBottom;
    private Stack<Integer> stackTailAtBottom; 
    private int head; // save for peek()
       
    public MyQueue() {
        this.stackHeadAtBottom = new Stack<Integer>();
        this.stackTailAtBottom = new Stack<Integer>();
    }
    
    public void push(int x) {
        if (this.empty()){
            this.stackHeadAtBottom.push(x); // first ele push
            this.head = x;
            return;
        }else if (!this.stackHeadAtBottom.empty() && this.stackTailAtBottom.empty()){
            this.stackHeadAtBottom.push(x); // O(1)
            return;
        }else { // O(n)
            while (!this.stackTailAtBottom.empty()){
                this.stackHeadAtBottom.push(this.stackTailAtBottom.pop());
            }
            this.head = this.stackHeadAtBottom.peek();
            this.stackHeadAtBottom.push(x);
        }
    }
    
    public int pop() {
        if (this.empty()){
            return -1;
        }else if (!this.stackHeadAtBottom.empty() && this.stackTailAtBottom.empty()){
            while (!this.stackHeadAtBottom.empty()){
                this.stackTailAtBottom.push(this.stackHeadAtBottom.pop());
            }
        }
        int oldheadvalue = this.stackTailAtBottom.pop();
        if (this.stackTailAtBottom.empty()){
            this.head = -1;
        }else{
            this.head = this.stackTailAtBottom.peek();
        }
        return oldheadvalue;
    }
    
    public int peek() {
        return this.head;
    }
    
    public boolean empty() {
        if (this.stackHeadAtBottom.empty() && this.stackTailAtBottom.empty()){
            return true;
        }
        return false;
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```