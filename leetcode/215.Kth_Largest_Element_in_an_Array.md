215. Kth Largest Element in an Array
难度
中等

https://leetcode-cn.com/problems/kth-largest-element-in-an-array/

Given an integer array nums and an integer k, return the kth largest element in the array.

Note that it is the kth largest element in the sorted order, not the kth distinct element.

 
```
Example 1:

Input: nums = [3,2,1,5,6,4], k = 2
Output: 5

Example 2:

Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4
 

Constraints:

1 <= k <= nums.length <= 104
-104 <= nums[i] <= 104
```

相关企业

Facebook|122

字节跳动|18

亚马逊 Amazon|18

领英 LinkedIn|17

微软 Microsoft|8


相关标签
- Array
- Divide and Conquer
- Quickselect
- Sorting
- Heap (Priority Queue)

相似题目
- Wiggle Sort II
中等
- Top K Frequent Elements
中等
- Third Maximum Number
简单
- Kth Largest Element in a Stream
简单
- K Closest Points to Origin
中等

# Slow: sort, Time O(nlogn);  Space O(1)
```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        nums = sorted(nums, reverse=True)
        return nums[k-1]
```        

# Partition,  Time O(n);  Space O(1) 
```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        numslen = len(nums)
        if not nums or k < 1 or k > numslen:
            return -1
        
        # k largest == len-k smallest
        return self.partition(nums, 0, numslen - 1, numslen - k)


    def partition(self, nums, start, end, k):
        # it has been guranteed start <= k <= end
        if start >= end:
            return nums[k]
        
        left = start
        right = end 
        pivotvalue = nums[(start + end) // 2]

        while left <= right:
            while left <= right and nums[left] < pivotvalue:
                left += 1
            while left <= right and nums[right] > pivotvalue:
                right -= 1

            if left <= right:
                nums[left], nums[right] = nums[right], nums[left]                
                left += 1
                right -= 1

        # this also works
        # self.partition(nums, start, right, k)
        # self.partition(nums, left, end, k)

        # faster than above one, not complete array need to be sorted, partial sorted is enough
        if k <= right: 
            self.partition(nums, start, right, k)
        if k >= left: 
            self.partition(nums, left, end, k)

        return nums[k]
```