15. 3Sum
难度
中等

Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

Notice that the solution set must not contain duplicate triplets.

 
```
Example 1:

Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]

Example 2:

Input: nums = []
Output: []

Example 3:

Input: nums = [0]
Output: []
 

Constraints:

0 <= nums.length <= 3000
-105 <= nums[i] <= 105
```

相关企业
半年内半年 ~ 1年1年 ~ 2年
字节跳动|27
亚马逊 Amazon|21
苹果 Apple|18
Facebook|18
谷歌 Google|9
加载更多

相关标签
Array
Two Pointers
Sorting

相似题目
Two Sum
简单
3Sum Closest
中等
4Sum
中等
3Sum Smaller
中等

```
方法1: 暴力枚举三个数复杂度为O(N^3) 

方法2:
先考虑2Sum的做法，假设升序数列a，对于一组解ai,aj, 另一组解ak,al 必然满足 i<k j>l 或 i>k j<l, 因此我们可以用两个指针，初始时指向数列两端 指向数之和大于目标值时，右指针向左移使得总和减小，反之左指针向右移 由此可以用 O(N)的复杂度解决2Sum问题，3Sum则枚举第一个数 O(N^2)。

使用有序数列的好处是，在枚举和移动指针时值相等的数可以跳过，省去去重部分
```

# solve version 
forloop each element then call find_two_sum()
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        if (not nums) or len(nums) < 3:
            return []

        nums = sorted(nums)

        result = []
        for target in nums:
            self.find_two_sum(nums, 0 - target, result)    

        # result = sorted(result)        
        return result

    def find_two_sum(self, nums, target: int, result: List[List[int]]) -> List[List[int]]:
        if not nums:
            return [[]]

        # remove the target which is already an element
        nums_temp = nums.copy()
        nums_temp.remove(0-target)

        left, right = 0, len(nums_temp) - 1
        twosum_result = []
        while (left < right):
            if nums_temp[left] + nums_temp[right] < target:
                left += 1
            elif nums_temp[left] + nums_temp[right] > target:
                right -= 1
            else:
                triplet = [nums_temp[left], nums_temp[right], 0 - target]
                # print(triplet)
                triplet = sorted(triplet)
                if triplet not in result:
                    result.append(triplet)
                left += 1
                right -= 1

        return result         
                
```
# Impove way:
1. repeat "target" can skip
2. 