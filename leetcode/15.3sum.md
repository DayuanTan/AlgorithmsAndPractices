15. 3Sum
难度
中等

Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

Notice that the solution set must not contain duplicate triplets.

 
```
Example 1:

Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]

Example 2:

Input: nums = []
Output: []

Example 3:

Input: nums = [0]
Output: []
 

Constraints:

0 <= nums.length <= 3000
-105 <= nums[i] <= 105
```

相关企业
半年内半年 ~ 1年1年 ~ 2年
字节跳动|27
亚马逊 Amazon|21
苹果 Apple|18
Facebook|18
谷歌 Google|9
加载更多

相关标签
Array
Two Pointers
Sorting

相似题目
Two Sum
简单
3Sum Closest
中等
4Sum
中等
3Sum Smaller
中等

```
方法1: 暴力枚举三个数复杂度为O(N^3) 

方法2:
先考虑2Sum的做法，假设升序数列a，对于一组解ai,aj, 另一组解ak,al 必然满足 i<k j>l 或 i>k j<l, 因此我们可以用两个指针，初始时指向数列两端 指向数之和大于目标值时，右指针向左移使得总和减小，反之左指针向右移 由此可以用 O(N)的复杂度解决2Sum问题，3Sum则枚举第一个数 O(N^2)。

使用有序数列的好处是，在枚举和移动指针时值相等的数可以跳过，省去去重部分
```

# solve version 
forloop each element then call find_two_sum()
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        if (not nums) or len(nums) < 3:
            return []

        nums = sorted(nums)

        result = []
        for target in nums:
            self.find_two_sum(nums, 0 - target, result)    

        # result = sorted(result)        
        return result

    def find_two_sum(self, nums, target: int, result: List[List[int]]) -> List[List[int]]:
        if not nums:
            return [[]]

        # remove the target which is already an element
        nums_temp = nums.copy()
        nums_temp.remove(0-target)

        left, right = 0, len(nums_temp) - 1
        while (left < right):
            if nums_temp[left] + nums_temp[right] < target:
                left += 1
            elif nums_temp[left] + nums_temp[right] > target:
                right -= 1
            else:
                triplet = [nums_temp[left], nums_temp[right], 0 - target]
                # print(triplet)
                triplet = sorted(triplet)
                if triplet not in result:
                    result.append(triplet)
                left += 1
                right -= 1

        return result         
                
```
# Impove way:
1. repeat "target" can skip
2. don't use whole "nums" when call find_two_sum(), then don't need to remove "target" element

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        if (not nums) or len(nums) < 3:
            return []

        nums = sorted(nums)

        result = []
        for i in range(0, len(nums) - 1 - 1):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            self.find_two_sum(nums, 0 - nums[i], i + 1, len(nums) - 1, result) # use nums[i] as target    
              
        return result

    def find_two_sum(self, nums, target: int, left: int, right: int, result: List[List[int]]) -> List[List[int]]:
        if not nums:
            return [[]]

        while (left < right):
            if nums[left] + nums[right] < target:
                left += 1
            elif nums[left] + nums[right] > target:
                right -= 1
            else:
                triplet = [nums[left], nums[right], 0 - target]
                # print(triplet)
                triplet = sorted(triplet)
                if triplet not in result:
                    result.append(triplet)
                left += 1
                right -= 1
                
                # faster by skipping unnecessary 
                while left < right and nums[left] == nums[left - 1]:
                    left += 1
                while left < right and nums[right] == nums[right + 1]:
                    right -= 1

        return result         
                
        
```

# Fastest:
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums = sorted(nums)
        results = []
        length = len(nums)
        for i in range(0, length - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            self.find_two_sum(nums, i + 1, length - 1, -nums[i], results)
        return results

    def find_two_sum(self, nums, left, right, target, results):
        while left < right:
            if nums[left] + nums[right] == target:
                results.append([-target, nums[left], nums[right]])
                right -= 1
                left += 1
                while left < right and nums[left] == nums[left - 1]:
                    left += 1
                while left < right and nums[right] == nums[right + 1]:
                    right -= 1
            elif nums[left] + nums[right] > target:
                right -= 1
            else:
                left += 1
```

# java
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        if (nums == null || nums.length < 3){
            return result;
        }

        Arrays.sort(nums);


        for (int i = 0; i < nums.length; i++){
            if (i > 0 && nums[i] == nums[i-1]){
                continue;
            }
            this.findTwoSum(nums, 0-nums[i], i+1, nums.length-1, result);
        }
        return result;
    }

    public void findTwoSum(int[] nums, int target, int left, int right, List<List<Integer>> result){
        if (nums == null || nums.length < 3){
            return;
        }

        while (left < right){
            if (nums[left] + nums[right] == target){
                List<Integer> triplet = new ArrayList<Integer>();
                triplet.add(nums[left]);
                triplet.add(nums[right]);
                triplet.add(0-target);
                Collections.sort(triplet);
                
                if (!result.contains(triplet)){
                    result.add(triplet);
                }

                left += 1;
                right -= 1;
                while (left < right && nums[left] == nums[left-1]){
                    left += 1;
                }
                while (left < right && nums[right] == nums[right+1]){
                    right -= 1;
                }
            }else if (nums[left] + nums[right] < target){
                left += 1;
            }else {
                right -= 1;
            }
        }
    }
}
```